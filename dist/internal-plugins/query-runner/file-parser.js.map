{"version":3,"sources":["../../../src/internal-plugins/query-runner/file-parser.js"],"names":["fs","require","crypto","babylon","report","getGraphQLTag","apiRunnerNode","getMissingNameErrorMessage","file","stripIndent","parseToAst","filePath","fileStr","ast","transpiled","filename","contents","length","item","tmp","parse","sourceType","plugins","error","undefined","sourceFilename","findGraphQLTags","text","Promise","resolve","reject","then","queries","ExportNamedDeclaration","path","state","traverse","TaggedTemplateExpression","innerPath","gqlAst","definitions","forEach","def","name","value","panic","push","catch","cache","FileParser","parseFile","readFileSync","indexOf","hash","createHash","update","digest","astDefinitions","kind","err","parseFiles","files","documents","Map","all","map","doc","set"],"mappings":"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","file":"file-parser.js","sourcesContent":["// @flow\nconst fs = require(`fs-extra`)\nconst crypto = require(`crypto`)\n\n// Traverse is a es6 module...\nimport traverse from \"babel-traverse\"\nconst babylon = require(`babylon`)\n\nconst report = require(`../../reporter`)\nconst { getGraphQLTag } = require(`../../utils/babel-plugin-extract-graphql`)\n\nimport type { DocumentNode, DefinitionNode } from \"graphql\"\n\nconst apiRunnerNode = require(`../../utils/api-runner-node`)\n\nconst getMissingNameErrorMessage = file => report.stripIndent`\n  GraphQL definitions must be \"named\".\n  The query with the missing name is in ${file}.\n  To fix the query, add \"query MyQueryName\" to the start of your query.\n  So instead of:\n    {\n      allMarkdownRemark {\n        totalCount\n      }\n    }\n\n  Do:\n    query MyQueryName {\n      allMarkdownRemark {\n        totalCount\n      }\n    }\n`\nasync function parseToAst(filePath, fileStr) {\n  let ast\n\n  // Preprocess and attempt to parse source; return an AST if we can, log an\n  // error if we can't.\n  const transpiled = await apiRunnerNode(`preprocessSource`, {\n    filename: filePath,\n    contents: fileStr,\n  })\n\n  if (transpiled && transpiled.length) {\n    for (const item of transpiled) {\n      try {\n        const tmp = babylon.parse(item, {\n          sourceType: `module`,\n          plugins: [`*`],\n        })\n        ast = tmp\n        break\n      } catch (error) {\n        report.error(error)\n        continue\n      }\n    }\n    if (ast === undefined) {\n      report.error(`Failed to parse preprocessed file ${filePath}`)\n    }\n  } else {\n    try {\n      ast = babylon.parse(fileStr, {\n        sourceType: `module`,\n        sourceFilename: true,\n        plugins: [`*`],\n      })\n    } catch (error) {\n      report.error(\n        `There was a problem parsing \"${filePath}\"; any GraphQL ` +\n          `fragments or queries in this file were not processed. \\n` +\n          `This may indicate a syntax error in the code, or it may be a file type ` +\n          `That Gatsby does not know how to parse.`,\n        error\n      )\n    }\n  }\n\n  return ast\n}\n\nasync function findGraphQLTags(file, text): Promise<Array<DefinitionNode>> {\n  return new Promise((resolve, reject) => {\n    parseToAst(file, text)\n      .then(ast => {\n        let queries = []\n        if (!ast) {\n          resolve(queries)\n          return\n        }\n\n        traverse(ast, {\n          ExportNamedDeclaration(path, state) {\n            path.traverse({\n              TaggedTemplateExpression(innerPath) {\n                const gqlAst = getGraphQLTag(innerPath)\n                if (gqlAst) {\n                  gqlAst.definitions.forEach(def => {\n                    if (!def.name || !def.name.value) {\n                      report.panic(getMissingNameErrorMessage(file))\n                    }\n                  })\n\n                  queries.push(...gqlAst.definitions)\n                }\n              },\n            })\n          },\n        })\n        resolve(queries)\n      })\n      .catch(reject)\n  })\n}\n\nconst cache = {}\n\nexport default class FileParser {\n  async parseFile(file: string): Promise<?DocumentNode> {\n    // TODO figure out why fs-extra isn't returning a promise\n    const text = fs.readFileSync(file, `utf8`)\n\n    if (text.indexOf(`graphql`) === -1) return null\n    const hash = crypto\n      .createHash(`md5`)\n      .update(file)\n      .update(text)\n      .digest(`hex`)\n\n    try {\n      let astDefinitions =\n        cache[hash] || (cache[hash] = await findGraphQLTags(file, text))\n\n      return astDefinitions.length\n        ? {\n            kind: `Document`,\n            definitions: astDefinitions,\n          }\n        : null\n    } catch (err) {\n      report.error(\n        `There was a problem parsing the GraphQL query in file: ${file}`,\n        err\n      )\n      return null\n    }\n  }\n\n  async parseFiles(files: Array<string>): Promise<Map<string, DocumentNode>> {\n    const documents = new Map()\n\n    return Promise.all(\n      files.map(file =>\n        this.parseFile(file).then(doc => {\n          if (!doc) return\n          documents.set(file, doc)\n        })\n      )\n    ).then(() => documents)\n  }\n}\n"]}