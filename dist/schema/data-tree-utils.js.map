{"version":3,"sources":["../../src/schema/data-tree-utils.js"],"names":["_","require","flatten","typeOf","createKey","INVALID_VALUE","Symbol","isDefined","v","isSameType","a","b","areAllSameType","list","every","current","i","prev","undefined","isEmptyObjectOrArray","obj","isDate","isObject","isEmpty","value","key","extractFieldExamples","nodes","mergeWith","isArray","cloneDeep","next","po","pn","stack","isNumber","isInteger","array","concat","filter","length","includes","slice","merged","buildFieldEnumValues","enumValues","values","maxDepth","safe","delimiter","Object","keys","forEach","field","extractFieldNames","module","exports"],"mappings":"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","file":"data-tree-utils.js","sourcesContent":["// @flow\nconst _ = require(`lodash`)\nconst flatten = require(`flat`)\nconst typeOf = require(`type-of`)\n\nconst createKey = require(`./create-key`)\n\nconst INVALID_VALUE = Symbol(`INVALID_VALUE`)\nconst isDefined = v => v != null\n\nconst isSameType = (a, b) => a == null || b == null || typeOf(a) === typeOf(b)\nconst areAllSameType = list =>\n  list.every((current, i) => {\n    let prev = i ? list[i - 1] : undefined\n    return isSameType(prev, current)\n  })\n\nconst isEmptyObjectOrArray = (obj: any): boolean => {\n  if (obj === INVALID_VALUE) {\n    return true\n  } else if (_.isDate(obj)) {\n    return false\n    // Simple \"is object empty\" check.\n  } else if (_.isObject(obj) && _.isEmpty(obj)) {\n    return true\n  } else if (_.isObject(obj)) {\n    return _.every(obj, (value, key) => {\n      if (!isDefined(value)) {\n        return true\n      } else if (_.isObject(value)) {\n        return isEmptyObjectOrArray(value)\n      } else {\n        return false\n      }\n    })\n  }\n  return false\n}\n\n/**\n * Takes an array of source nodes and returns a pristine\n * example that can be used to infer types.\n *\n * Arrays are flattened to either: `null` for empty or sparse arrays or a\n * an array of a sigle merged example. e.g:\n *\n *  - ['red'], ['blue', 'yellow'] -> ['red']\n *  - [{ color: 'red'}, { color: 'blue', ht: 5 }] -> [{ color: 'red', ht: 5 }]\n *\n * @param {*Nodes} args\n */\nconst extractFieldExamples = (nodes: any[]) =>\n  // $FlowFixMe\n  _.mergeWith(\n    _.isArray(nodes[0]) ? [] : {},\n    ..._.cloneDeep(nodes),\n    (obj, next, key, po, pn, stack) => {\n      if (obj === INVALID_VALUE) return obj\n\n      // TODO: if you want to support infering Union types this should be handled\n      // differently. Maybe merge all like types into examples for each type?\n      // e.g. union: [1, { foo: true }, ['brown']] -> Union Int|Object|List\n      if (!isSameType(obj, next)) {\n        return INVALID_VALUE\n      }\n\n      if (!_.isArray(obj || next)) {\n        // Prefer floats over ints as they're more specific.\n        if (obj && _.isNumber(obj) && !_.isInteger(obj)) return obj\n        if (obj === null) return next\n        if (next === null) return obj\n        return undefined\n      }\n\n      let array = [].concat(obj, next).filter(isDefined)\n\n      if (!array.length) return null\n      if (!areAllSameType(array)) return INVALID_VALUE\n\n      // Linked node arrays don't get reduced further as we\n      // want to preserve all the linked node types.\n      if (_.includes(key, `___NODE`)) {\n        return array\n      }\n\n      // primitive values don't get merged further, just take the first item\n      if (!_.isObject(array[0])) return array.slice(0, 1)\n      let merged = extractFieldExamples(array)\n      return isDefined(merged) ? [merged] : null\n    }\n  )\n\nconst buildFieldEnumValues = (nodes: any[]) => {\n  const enumValues = {}\n  const values = flatten(extractFieldExamples(nodes), {\n    maxDepth: 3,\n    safe: true, // don't flatten arrays.\n    delimiter: `___`,\n  })\n  Object.keys(values).forEach(field => {\n    if (values[field] == null) return\n    enumValues[createKey(field)] = { field }\n  })\n\n  return enumValues\n}\n\n// extract a list of field names\n// nested objects get flattened to \"outer___inner\" which will be converted back to\n// \"outer.inner\" by run-sift\nconst extractFieldNames = (nodes: any[]) => {\n  const values = flatten(extractFieldExamples(nodes), {\n    maxDepth: 3,\n    safe: true, // don't flatten arrays.\n    delimiter: `___`,\n  })\n\n  return Object.keys(values)\n}\n\nmodule.exports = {\n  INVALID_VALUE,\n  extractFieldExamples,\n  buildFieldEnumValues,\n  extractFieldNames,\n  isEmptyObjectOrArray,\n}\n"]}