{"version":3,"sources":["../../src/schema/build-connection-fields.js"],"names":["_","require","GraphQLInt","GraphQLList","GraphQLString","GraphQLEnumType","connectionArgs","connectionDefinitions","connectionFromArray","buildFieldEnumValues","module","exports","type","enumValues","nodes","connectionType","groupConnection","name","camelCase","nodeType","nodeObjectType","connectionFields","field","fieldValue","totalCount","distinct","args","values","resolve","connection","fieldName","includes","replace","fields","edges","map","edge","get","node","sortBy","filter","uniq","flatten","identity","group","connectionNodes","groups","isArray","find","reduce","vals","n","has","concat","forEach","val","groupBy","groupConnections","sortedFieldValues","keys","each","groupNodes","groupConn","length","push"],"mappings":"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","file":"build-connection-fields.js","sourcesContent":["// @flow\nconst _ = require(`lodash`)\nconst {\n  GraphQLInt,\n  GraphQLList,\n  GraphQLString,\n  GraphQLEnumType,\n} = require(`graphql`)\nconst {\n  connectionArgs,\n  connectionDefinitions,\n  connectionFromArray,\n} = require(`graphql-skip-limit`)\n\nconst { buildFieldEnumValues } = require(`./data-tree-utils`)\n\nmodule.exports = type => {\n  const enumValues = buildFieldEnumValues(type.nodes)\n  const { connectionType: groupConnection } = connectionDefinitions({\n    name: _.camelCase(`${type.name} groupConnection`),\n    nodeType: type.nodeObjectType,\n    connectionFields: () => {\n      return {\n        field: { type: GraphQLString },\n        fieldValue: { type: GraphQLString },\n        totalCount: { type: GraphQLInt },\n      }\n    },\n  })\n\n  return {\n    totalCount: {\n      type: GraphQLInt,\n    },\n    distinct: {\n      type: new GraphQLList(GraphQLString),\n      args: {\n        field: {\n          type: new GraphQLEnumType({\n            name: _.camelCase(`${type.name} distinct enum`),\n            values: enumValues,\n          }),\n        },\n      },\n      resolve(connection, args) {\n        let fieldName = args.field\n        if (_.includes(args.field, `___`)) {\n          fieldName = args.field.replace(`___`, `.`)\n        }\n        const fields = connection.edges.map(edge => _.get(edge.node, fieldName))\n        return _.sortBy(_.filter(_.uniq(_.flatten(fields)), _.identity))\n      },\n    },\n    group: {\n      type: new GraphQLList(groupConnection),\n      args: {\n        ...connectionArgs,\n        field: {\n          type: new GraphQLEnumType({\n            name: _.camelCase(`${type.name} group enum`),\n            values: enumValues,\n          }),\n        },\n      },\n      resolve(connection, args) {\n        const fieldName = args.field.replace(`___`, `.`)\n        const connectionNodes = connection.edges.map(edge => edge.node)\n\n        let groups = {}\n        // Do a custom grouping for arrays (w/ a group per array value)\n        // Find the first node with this field and check if it's an array.\n        if (_.isArray(_.get(_.find(connectionNodes, fieldName), fieldName))) {\n          const values = _.uniq(\n            _.reduce(\n              connectionNodes,\n              (vals, n) => {\n                if (_.has(n, fieldName)) {\n                  return vals.concat(_.get(n, fieldName))\n                } else {\n                  return vals\n                }\n              },\n              []\n            )\n          )\n          values.forEach(val => {\n            groups[val] = _.filter(connectionNodes, n =>\n              _.includes(_.get(n, fieldName), val)\n            )\n          })\n        } else {\n          groups = _.groupBy(connectionNodes, fieldName)\n        }\n        const groupConnections = []\n\n        // Do default sort by fieldValue\n        const sortedFieldValues = _.sortBy(_.keys(groups))\n        _.each(sortedFieldValues, fieldValue => {\n          const groupNodes = groups[fieldValue]\n          const groupConn = connectionFromArray(groupNodes, args)\n          groupConn.totalCount = groupNodes.length\n          groupConn.field = fieldName\n          groupConn.fieldValue = fieldValue\n          groupConnections.push(groupConn)\n        })\n\n        return groupConnections\n      },\n    },\n  }\n}\n"]}